#!/usr/bin/env python3

import os
import sys
import re
import logging
import datetime
import time
import shutil
import subprocess
import json
from concurrent.futures import ThreadPoolExecutor
import typer
from pyfiglet import Figlet
from typing import Optional, List, Dict, Any
from pathlib import Path
import psutil

from rich.panel import Panel
from rich.align import Align
from rich.text import Text
from rich.table import Table
from rich.progress import Progress, BarColumn, SpinnerColumn, TimeElapsedColumn, MofNCompleteColumn, TaskID, TextColumn

# --- Add path to modules and import them ---
SHARE_DIR = "/usr/local/share/shadowmap/"
if SHARE_DIR not in sys.path:
    sys.path.insert(0, SHARE_DIR)

try:
    import config
    import utils
    import phase0_osint
    import phase1_subdomain
    import phase2_port_scanning
    import phase3_dirsearch
    import phase4_webcrawling
except ImportError as e:
    print(f"BŁĄD: Nie można zaimportować modułów z {SHARE_DIR}. Uruchom install.py. Błąd: {e}", file=sys.stderr)
    sys.exit(1)

app = typer.Typer(add_completion=False, help="ShadowMap: Zautomatyzowany zestaw narzędzi do rekonesansu.")

def display_banner():
    f = Figlet(font='slant')
    banner_text = f.renderText('ShadowMap')
    utils.console.print(Align.center(Text(banner_text, style="bold cyan")))
    utils.console.print(Align.center("--- Automated Reconnaissance Toolkit ---", style="bold yellow"))
    utils.console.print(Align.center("[dim white]Made by Xzar[/dim white]\n"))

def ask_scan_scope(all_results: List[str], critical_results: List[str], phase_name: str) -> Optional[List[str]]:
    summary_text = (
        f"Znaleziono [bold green]{len(all_results)}[/bold green] wyników.\n"
        f"W tym [bold red]{len(critical_results)}[/bold red] krytycznych."
    )
    panel = Panel(Text.from_markup(summary_text, justify="center"), border_style="cyan", title="[cyan]Podsumowanie[/cyan]")
    utils.console.print(Align.center(panel))

    question = f"Co skanować w {phase_name}?\n" \
               f"([bold]A[/bold])ll - wszystkie {len(all_results)}\n" \
               f"([bold]C[/bold])ritical - tylko {len(critical_results)}"
    
    choice = utils.ask_user_decision(question, choices=["a", "c"], default="a")
    return all_results if choice.lower() == 'a' else critical_results

def display_main_menu():
    utils.console.clear()
    display_banner()
    utils.console.print(Align.center(Panel.fit("[bold cyan]ShadowMap Main Menu[/bold cyan]")))
    utils.console.print(Align.center(f"\nObecny cel: [bold green]{config.ORIGINAL_TARGET}[/bold green]\n"))
    
    table = Table(show_header=False, show_edge=False, padding=(0, 2))
    table.add_row("[1]", "Faza 1: Odkrywanie Subdomen")
    table.add_row("[2]", "Faza 2: Skanowanie Portów")
    table.add_row("[3]", "Faza 3: Wyszukiwanie Katalogów")
    table.add_row("[4]", "Faza 4: Web Crawling")
    table.add_section()
    table.add_row("[\fq]", "Zapisz raport i Wyjdź")
    utils.console.print(Align.center(table))
    
    return utils.get_single_char_input_with_prompt(Text.from_markup("\n[bold cyan]Wybierz fazę do uruchomienia[/bold cyan]", justify="center"))

def parse_target_input(target_input: str):
    config.ORIGINAL_TARGET = target_input
    clean_target = re.sub(r'^(https|http)://', '', target_input).strip('/')
    config.TARGET_IS_IP = bool(re.match(r"^\d{1,3}(\.\d{1,3}){3}$", clean_target))

    if not config.TARGET_IS_IP:
        hostname_match = re.search(r'([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', clean_target)
        if hostname_match:
            config.HOSTNAME_TARGET = hostname_match.group(1)
            parts = config.HOSTNAME_TARGET.split('.')
            config.CLEAN_DOMAIN_TARGET = '.'.join(parts[-2:]) if len(parts) > 1 else config.HOSTNAME_TARGET
        else:
            config.HOSTNAME_TARGET = clean_target
            config.CLEAN_DOMAIN_TARGET = clean_target
    else:
        config.HOSTNAME_TARGET = clean_target
        config.CLEAN_DOMAIN_TARGET = clean_target

    utils.console.print(Align.center(f"[green]Hostname: {config.HOSTNAME_TARGET} | Domena: {config.CLEAN_DOMAIN_TARGET}[/green]"))

def detect_waf_and_propose_safe_mode():
    utils.console.print(Align.center(Panel(Text("Sprawdzam ochronę WAF...", justify="center"), title="[cyan]Detekcja WAF[/cyan]")))
    
    try:
        command = ["wafw00f", "-T", "150", "--no-colors", config.ORIGINAL_TARGET]
        process = subprocess.run(command, capture_output=True, text=True, timeout=300)
        
        waf_name = re.search(r'is behind\s+([^\n(]+)', process.stdout)
        
        if waf_name:
            utils.console.print(Align.center(Panel(Text.from_markup(f"[red]Wykryto WAF:[/red] [blue]{waf_name.group(1).strip()}[/blue]", justify="center"), title="[yellow]Wynik[/yellow]")))
            if utils.ask_user_decision("Włączyć Tryb Bezpieczny?", ["y", "n"], "y") == 'y':
                config.SAFE_MODE = True
                if utils.is_tor_active():
                    utils.console.print(Align.center("[green]✓ Usługa Tor aktywna. Proxy zostanie ustawione.[/green]"))
                    if not config.USER_CUSTOMIZED_PROXY:
                        config.PROXY = "socks5://127.0.0.1:9050"
                else:
                    utils.console.print(Align.center(Panel(Text("Usługa Tor [red]NIE JEST AKTYWNA[/red].\nTryb Bezpieczny będzie kontynuowany [yellow]BEZ Tora[/yellow].", justify="center"), title="[yellow]Ostrzeżenie[/yellow]")))
        else:
            utils.console.print(Align.center(Panel(Text("Nie wykryto WAF.", justify="center"), title="[green]Wynik[/green]")))

    except Exception as e:
        utils.log_and_echo(f"Błąd podczas uruchamiania wafw00f: {e}", "ERROR")

def open_html_report(report_path: str):
    if not report_path or not os.path.exists(report_path):
        utils.console.print(f"[yellow]Ostrzeżenie: Plik raportu '{report_path}' nie istnieje. Nie można go otworzyć.[/yellow]")
        return

    utils.console.print(f"[cyan]Próba otwarcia raportu: {report_path}[/cyan]")
    try:
        if sys.platform == "darwin":
            subprocess.run(["open", report_path], check=True)
        elif sys.platform.startswith("linux"):
            subprocess.run(["xdg-open", report_path], check=True)
        elif sys.platform == "win32":
            os.startfile(report_path)
        else:
            utils.console.print("[yellow]Nieznany system operacyjny. Otwórz raport ręcznie.[/yellow]")
    except (FileNotFoundError, subprocess.CalledProcessError) as e:
        utils.console.print(f"[red]Błąd podczas otwierania raportu. Otwórz go ręcznie.[/red]\n[dim]Szczegóły: {e}[/dim]")


def generate_html_report(p0_data, p1_files, active_urls_data, p2_results, p3_results, p3_verified_data, p4_results) -> Optional[str]:
    utils.console.print(Align.center("[blue]Generowanie raportu HTML...[/blue]"))
    
    def read_file_content(path: Optional[str]) -> str:
        if path and os.path.exists(path):
            try: return open(path, 'r', encoding='utf-8', errors='ignore').read()
            except Exception: return "Błąd odczytu"
        return "Brak danych"

    try:
        with open(config.HTML_TEMPLATE_PATH, 'r', encoding='utf-8') as f: template = f.read()
    except FileNotFoundError:
        utils.console.print(f"[red]BŁĄD: Nie znaleziono szablonu: {config.HTML_TEMPLATE_PATH}[/red]")
        return None
    
    p3_results_by_tool = p3_results.get("results_by_tool", {})
    all_subdomains_list = sorted(list(set((read_file_content(p1_files.get(t)) for t in ["Subfinder", "Assetfinder", "Findomain", "Puredns"]))))
    
    replacements = {
        "{{DOMAIN}}": config.HOSTNAME_TARGET,
        "{{OSINT_IP}}": p0_data.get('ip', 'Brak'),
        "{{OSINT_ASN_DETAILS}}": p0_data.get('asn_details', 'Brak'),
        "{{OSINT_CDN}}": p0_data.get('cdn_name', 'Brak'),
        "{{OSINT_REGISTRAR}}": p0_data.get('registrar', 'Brak'),
        "{{OSINT_CREATION_DATE}}": p0_data.get('creation_date', 'Brak'),
        "{{OSINT_EXPIRATION_DATE}}": p0_data.get('expiration_date', 'Brak'),
        "{{OSINT_NAME_SERVERS}}": '\n'.join(p0_data.get('name_servers', [])),
        "{{OSINT_TECHNOLOGIES}}": '\n'.join(p0_data.get('technologies', [])),
        "{{COUNT_ALL_SUBDOMAINS}}": str(len(all_subdomains_list)),
        "{{COUNT_HTTPX}}": str(len(active_urls_data)),
        "{{COUNT_OPEN_PORTS}}": str(sum(len(p) for p in p2_results.get("open_ports_by_host", {}).values())),
        "{{COUNT_DIR_SEARCH}}": str(len(p3_results.get("all_dirsearch_results", []))),
        "{{COUNT_ALL_URLS_P4}}": str(len(p4_results.get("all_urls", []))),
        "{{HTTPX_OUTPUT_JSON_P1}}": json.dumps(active_urls_data, indent=4),
        "{{HTTPX_OUTPUT_JSON_P3}}": json.dumps(p3_verified_data, indent=4),
        "{{NMAP_RESULTS_RAW_JSON}}": json.dumps({t: read_file_content(f) for t, f in p2_results.get("nmap_files", {}).items()}),
        "{{NAABU_RAW_OUTPUT}}": read_file_content(p2_results.get("naabu_file")).replace('`', '\\`'),
        "{{MASSCAN_RAW_OUTPUT}}": read_file_content(p2_results.get("masscan_file")).replace('`', '\\`'),
        "{{SUBFINDER_OUTPUT}}": read_file_content(p1_files.get("Subfinder")),
        "{{ASSETFINDER_OUTPUT}}": read_file_content(p1_files.get("Assetfinder")),
        "{{FINDOMAIN_OUTPUT}}": read_file_content(p1_files.get("Findomain")),
        "{{PUREDNS_OUTPUT}}": read_file_content(p1_files.get("Puredns")),
        "{{FFUF_OUTPUT}}": '\n'.join(p3_results_by_tool.get("Ffuf", [])),
        "{{FEROXBUSTER_OUTPUT}}": '\n'.join(p3_results_by_tool.get("Feroxbuster", [])),
        "{{DIRSEARCH_OUTPUT}}": '\n'.join(p3_results_by_tool.get("Dirsearch", [])),
        "{{GOBUSTER_OUTPUT}}": '\n'.join(p3_results_by_tool.get("Gobuster", [])),
        "{{PHASE4_ALL_URLS_OUTPUT}}": '\n'.join(p4_results.get("all_urls", [])),
        "{{PARAMETERS_OUTPUT}}": '\n'.join(p4_results.get("parameters", []))
    }
    
    for placeholder, value in replacements.items():
        template = template.replace(placeholder, str(value or "Brak danych"))

    report_path = os.path.join(config.REPORT_DIR, "report.html")
    with open(report_path, 'w', encoding='utf-8') as f: f.write(template)
    utils.console.print(f"[green]✓ Raport HTML wygenerowany: {report_path}[/green]")
    return report_path


def cleanup_temp_files():
    for f_path in config.TEMP_FILES_TO_CLEAN:
        try:
            if os.path.exists(f_path): os.remove(f_path)
        except OSError:
            pass

@app.command()
def main(
    target: Optional[str] = typer.Argument(None, help="Domena lub IP."),
    target_list: Optional[Path] = typer.Option(None, "-l", help="Plik z listą celów."),
    # ... inne opcje ...
):
    
    targets_to_scan = []
    if target_list and target_list.is_file():
        targets_to_scan.extend(l.strip() for l in open(target_list) if l.strip())
        config.QUIET_MODE = True 
    elif target:
        targets_to_scan.append(target)
    
    if not targets_to_scan:
        utils.console.print("[red]Błąd: Podaj cel lub listę celów.[/red]")
        raise typer.Exit()

    scan_initiated = False
    try:
        for current_target in targets_to_scan:
            p0_data, p1_files, active_urls_data = {}, {}, []
            p2_results, p3_results, p4_results = {}, {}, {}
            p3_verified_data = []
            
            parse_target_input(current_target)
            config.REPORT_DIR = os.path.join(config.OUTPUT_BASE_DIR, f"report_{config.HOSTNAME_TARGET}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}")
            os.makedirs(config.REPORT_DIR, exist_ok=True)
            scan_initiated = True

            if config.QUIET_MODE:
                # ... logika trybu cichego ...
                continue
            
            p0_data, best_target_url = phase0_osint.start_phase0_osint()
            config.ORIGINAL_TARGET = best_target_url # Aktualizacja celu
            detect_waf_and_propose_safe_mode()
            
            choice = ''
            while True:
                if not choice:
                    choice = display_main_menu()
                
                if choice == '1':
                    if phase1_subdomain.display_phase1_tool_selection_menu(display_banner):
                        p1_files, active_urls_data, _ = phase1_subdomain.start_phase1_scan()
                        if active_urls_data:
                            if utils.ask_user_decision("Zakończono Fazę 1. Kontynuować do Fazy 2 (Skanowanie Portów)?", ["y", "n"], "y") == 'y':
                                choice = '2'
                            else:
                                choice = ''
                                continue
                        else:
                            utils.console.print(Align.center("[yellow]Nie znaleziono aktywnych subdomen. Wracam do menu głównego.[/yellow]"))
                            time.sleep(2)
                            choice = ''
                            continue
                    else:
                        choice = ''
                
                if choice == '2':
                    if not active_urls_data:
                        utils.console.print(Align.center("[bold yellow]Najpierw uruchom Fazę 1, aby znaleźć aktywne subdomeny do skanowania.[/bold yellow]"))
                        time.sleep(2)
                        choice = ''
                        continue

                    if phase2_port_scanning.display_phase2_tool_selection_menu(display_banner):
                         targets_for_p2 = [item['url'] for item in active_urls_data]
                         p2_results = phase2_port_scanning.start_port_scan(targets_for_p2, None, None)
                         if p2_results and p2_results.get("open_ports_by_host"):
                             if utils.ask_user_decision("Zakończono Fazę 2. Kontynuować do Fazy 3 (Wyszukiwanie Katalogów)?", ["y", "n"], "y") == 'y':
                                 choice = '3'
                             else:
                                 choice = ''
                                 continue
                         else:
                            utils.console.print(Align.center("[yellow]Nie znaleziono otwartych portów. Wracam do menu głównego.[/yellow]"))
                            time.sleep(2)
                            choice = ''
                            continue
                    else:
                        choice = ''

                if choice == '3':
                    if phase3_dirsearch.display_phase3_tool_selection_menu(display_banner):
                        targets = [item['url'] for item in active_urls_data] or [config.ORIGINAL_TARGET]
                        
                        num_tools = sum(config.selected_phase3_tools)
                        total_tasks = len(targets) * num_tools
                        
                        with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"), BarColumn(), MofNCompleteColumn(), "•", TimeElapsedColumn(), console=utils.console, transient=True) as progress:
                            task = progress.add_task("[green]Faza 3: Wyszukiwanie katalogów[/green]", total=total_tasks if total_tasks > 0 else 1)
                            p3_results, p3_verified_data = phase3_dirsearch.start_dir_search(targets, progress, task)
                        
                        if utils.ask_user_decision("Zakończono Fazę 3. Kontynuować do Fazy 4 (Web Crawling)?", ["y", "n"], "y") == 'y':
                            choice = '4'
                        else:
                            choice = ''
                            continue
                    else:
                        choice = ''
                
                if choice == '4':
                    if phase4_webcrawling.display_phase4_tool_selection_menu(display_banner):
                        targets_for_p4 = [item['url'] for item in p3_verified_data] or [item['url'] for item in active_urls_data] or [config.ORIGINAL_TARGET]
                        num_tools = sum(config.selected_phase4_tools)
                        total_tasks = len(targets_for_p4) * num_tools
                        
                        with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"), BarColumn(), MofNCompleteColumn(), "•", TimeElapsedColumn(), console=utils.console, transient=True) as progress:
                            task = progress.add_task("[green]Faza 4: Web Crawling[/green]", total=total_tasks if total_tasks > 0 else 1)
                            p4_results = phase4_webcrawling.start_web_crawl(targets_for_p4, progress, task)
                        
                        utils.console.print(Align.center("[bold green]Faza 4 zakończona. Wracam do menu głównego.[/bold green]"))
                        time.sleep(2)
                    choice = '' # Po fazie 4 zawsze wracaj do menu

                if choice.lower() == 'q':
                    report_file_path = generate_html_report(p0_data, p1_files, active_urls_data, p2_results, p3_results, p3_verified_data, p4_results)
                    if report_file_path:
                        open_html_report(report_file_path)
                    break 

    except KeyboardInterrupt:
        utils.console.print("\n[yellow]Przerwano. Czyszczenie...[/yellow]")
    finally:
        if scan_initiated:
            cleanup_temp_files()

if __name__ == "__main__":
    app()

