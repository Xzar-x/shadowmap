#!/usr/bin/env python3

import os
import sys
import re
import logging
import datetime
import time
import shutil
import subprocess
import random
import typer
import json
from concurrent.futures import ThreadPoolExecutor, as_completed
from rich.console import Console
from rich.panel import Panel
from rich.progress import Progress, BarColumn, TextColumn, SpinnerColumn, TimeElapsedColumn, TaskProgressColumn, TaskID, MofNCompleteColumn
from rich.prompt import Prompt
from rich.align import Align
from rich.text import Text
from rich.table import Table
from rich.spinner import Spinner
from pyfiglet import Figlet
from typing import Optional, List, Dict, Tuple
from pathlib import Path

# --- Dodaj katalogi modułów do ścieżki systemowej Pythona ---
SHARE_DIR = "/usr/local/share/shadowmap/"
if SHARE_DIR not in sys.path:
    sys.path.insert(0, SHARE_DIR)

# --- Importowanie logiki Fazy 2 i Fazy 3 ---
try:
    from phase2_dirsearch import (
        start_dir_search as phase2_start_dir_search,
        get_random_user_agent_header as shared_get_random_user_agent_header,
        shuffle_wordlist as shared_shuffle_wordlist,
        get_random_browser_headers as shared_get_random_browser_headers
    )
    from Phase3_webcrawling import start_web_crawl as phase3_start_web_crawl
except ImportError as e:
    print(f"BŁĄD: Nie można zaimportować modułu Fazy 2 lub 3 z {SHARE_DIR}. Upewnij się, że pliki istnieją i mają prawidłowe uprawnienia. Błąd: {e}", file=sys.stderr)
    sys.exit(1)

# Modules for single character input on Unix/Linux
if sys.platform != "win32":
    import tty
    import termios
    def get_single_char_input() -> str:
        fd = sys.stdin.fileno()
        old_settings = termios.tcgetattr(fd)
        try:
            tty.setraw(fd)
            char = sys.stdin.read(1)
        finally:
            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
        return char
else:
    def get_single_char_input() -> str:
        return input("")

# Rich configuration
console = Console()

# --- Global Variables ---
LOG_FILE = ""
QUIET_MODE = False
OUTPUT_BASE_DIR = os.getcwd()
REPORT_DIR = ""
TEMP_FILES_TO_CLEAN = []
SAFE_MODE = False
CUSTOM_HEADER = ""
SCAN_ONLY_CRITICAL = False
selected_phase1_tools = [0, 0, 0, 0] # Subfinder, Assetfinder, Findomain, Puredns
selected_phase2_tools = [0, 0, 0, 0] # Ffuf, Feroxbuster, Dirsearch, Gobuster
selected_phase3_tools = [0, 0, 0, 0, 0] # Katana, Hakrawler, ParamSpider, LinkFinder, gauplus
TARGET_IS_IP = False
ORIGINAL_TARGET = ""
HOSTNAME_TARGET = "" 
CLEAN_DOMAIN_TARGET = ""

# Domyślne wartości
DEFAULT_WORDLIST_PHASE1 = "/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt"
SMALL_WORDLIST_PHASE1 = "/usr/local/share/shadowmap/subdomen_wordlist.txt"
WORDLIST_PHASE1 = DEFAULT_WORDLIST_PHASE1

DEFAULT_WORDLIST_PHASE2 = "/usr/share/seclists/Discovery/Web-Content/common.txt"
SMALL_WORDLIST_PHASE2 = "/usr/local/share/shadowmap/dir_wordlist.txt"
WORDLIST_PHASE2 = DEFAULT_WORDLIST_PHASE2

DEFAULT_THREADS = 40
THREADS = DEFAULT_THREADS

DEFAULT_TOOL_TIMEOUT_SECONDS = 1800
TOOL_TIMEOUT_SECONDS = DEFAULT_TOOL_TIMEOUT_SECONDS

DEFAULT_RECURSION_DEPTH = 1
RECURSION_DEPTH = DEFAULT_RECURSION_DEPTH

DEFAULT_RESOLVERS_FILE = "/usr/local/share/shadowmap/resolvers.txt"
RESOLVERS_FILE = DEFAULT_RESOLVERS_FILE

# Flagi ręcznych zmian
USER_CUSTOMIZED_WORDLIST_PHASE1 = False
USER_CUSTOMIZED_WORDLIST_PHASE2 = False
USER_CUSTOMIZED_USER_AGENT = False
USER_CUSTOMIZED_THREADS = False
USER_CUSTOMIZED_TIMEOUT = False
USER_CUSTOMIZED_RECURSION_DEPTH = False
USER_CUSTOMIZED_RESOLVERS = False
USER_CUSTOMIZED_SCAN_CRITICAL = False

HTML_TEMPLATE_PATH = "/usr/local/share/shadowmap/report_template.html"
USER_AGENTS_FILE = "/usr/local/share/shadowmap/user_agents.txt"

LOG_COLOR_MAP = {"INFO": "green", "WARN": "yellow", "ERROR": "red", "DEBUG": "blue"}

def log_and_echo(message: str, level: str = "INFO"):
    log_level = getattr(logging, level.upper(), logging.INFO)
    color = LOG_COLOR_MAP.get(level.upper(), "white")
    if level == "ERROR":
        console.print(message, style=f"bold {color}")
    if LOG_FILE:
        logging.log(log_level, message)

def display_banner():
    f = Figlet(font='slant')
    banner_text = f.renderText('ShadowMap')
    console.print(Align.center(Text(banner_text, style="bold cyan")))
    console.print(Align.center("--- Automated Reconnaissance Toolkit ---", style="bold yellow"))
    console.print(Align.center("[dim white]Made by Xzar[/dim white]\n"))

def filter_critical_urls(urls: List[str]) -> List[str]:
    critical_keywords = ['admin', 'login', 'logon', 'signin', 'auth', 'panel', 'dashboard', 'config', 'backup', 'dump', 'sql', 'db', 'database', 'api', 'graphql', 'debug', 'trace', 'test', 'dev', 'staging', '.git', '.env', '.docker', 'credentials', 'password', 'secret', 'token', 'key', 'jwt', 'oauth', 'phpinfo', 'status', 'metrics']
    return [url for url in urls if any(keyword in url.lower() for keyword in critical_keywords)]

def get_single_char_input_with_prompt(prompt_text: Text, choices: Optional[List[str]] = None, default: Optional[str] = None) -> str:
    console.print(Align.center(prompt_text), end="")
    choice = get_single_char_input()
    console.print(choice)
    if choices and default and choice.strip() == '':
        return default
    return choice

def ask_user_decision(question: str, choices: List[str], default: str) -> str:
    """Wyświetla pytanie w panelu i prosi o odpowiedź użytkownika."""
    panel = Panel(Text.from_markup(question, justify="center"), border_style="yellow", title="[yellow]Pytanie[/yellow]", expand=False)
    console.print(Align.center(panel))
    
    choice_str = '/'.join(f"[bold]{c}[/bold]" for c in choices)
    prompt_str = f"\n[cyan]Wybierz opcję ({choice_str})[/cyan] [dim]({default}=Enter)[/dim]: "
    return Prompt.ask(prompt_str, choices=choices, default=default)

def display_phase1_tool_selection_menu():
    global selected_phase1_tools, SAFE_MODE
    while True:
        console.clear()
        display_banner()
        console.print(Align.center(Panel.fit("[bold magenta]Faza 1: Odkrywanie Subdomen[/bold magenta]")))
        console.print(Align.center(f"Obecny cel: [bold green]{ORIGINAL_TARGET}[/bold green]"))
        console.print(Align.center(f"Tryb bezpieczny: {'[bold green]WŁĄCZONY[/bold green]' if SAFE_MODE else '[bold red]WYŁĄCZONY'}"))
        
        table = Table(show_header=False, show_edge=False, padding=(0, 2))
        table.add_column("Key", style="bold blue", justify="center", min_width=5)
        table.add_column("Description", style="white", justify="left")

        tool_names = ["Subfinder", "Assetfinder", "Findomain", "Puredns (bruteforce)"]
        
        for i, tool_name in enumerate(tool_names):
            status_char = "[bold green]✓[/bold green]" if selected_phase1_tools[i] == 1 else "[bold red]✗[/bold red]"
            if TARGET_IS_IP and i < 3:
                table.add_row(f"[{i+1}]", f"[dim]{status_char}[/dim] [dim]{tool_name} (pominięto dla IP)[/dim]")
            else:
                table.add_row(f"[{i+1}]", f"{status_char} {tool_name}")

        table.add_section()
        table.add_row("[5]", "[bold magenta]Zmień ustawienia Fazy 1[/bold magenta]")
        table.add_row("[\fb]", "Powrót do menu głównego")
        table.add_row("[\fq]", "Wyjdź")
        console.print(Align.center(table))

        choice = get_single_char_input_with_prompt(Text.from_markup("[bold cyan]Wybierz opcję[/bold cyan]", justify="center"))
        
        if choice.isdigit() and 1 <= int(choice) <= 4:
            idx = int(choice) - 1
            if TARGET_IS_IP and idx < 3:
                console.print(Align.center("[bold yellow]Nie można włączyć narzędzi pasywnych dla celu IP.[/bold yellow]"))
            else:
                selected_phase1_tools[idx] = 1 - selected_phase1_tools[idx]
        elif choice == '5':
            display_phase1_settings_menu()
        elif choice.lower() == 'q':
            sys.exit(0)
        elif choice.lower() == 'b':
            return False
        elif choice == '\r':
            if any(selected_phase1_tools):
                return True
            else:
                 console.print(Align.center("[bold yellow]Proszę wybrać co najmniej jedno narzędzie lub wrócić/wyjść.[/bold yellow]"))
        else:
            console.print(Align.center("[bold yellow]Nieprawidłowa opcja. Spróbuj ponownie.[/bold yellow]"))
        time.sleep(0.1)

def display_phase1_settings_menu():
    global WORDLIST_PHASE1, THREADS, TOOL_TIMEOUT_SECONDS, SAFE_MODE, CUSTOM_HEADER, RESOLVERS_FILE
    global USER_CUSTOMIZED_WORDLIST_PHASE1, USER_CUSTOMIZED_USER_AGENT, USER_CUSTOMIZED_THREADS, USER_CUSTOMIZED_TIMEOUT, USER_CUSTOMIZED_RESOLVERS
    while True:
        console.clear()
        display_banner()
        console.print(Align.center(Panel.fit("[bold cyan]Ustawienia Fazy 1[/bold cyan]")))
        table = Table(show_header=False, show_edge=False, padding=(0, 2))
        table.add_column("Key", style="bold blue", justify="center", min_width=5)
        table.add_column("Description", style="white", justify="left")
        table.add_row("[1]", f"[{'[bold green]✓[/bold green]' if SAFE_MODE else '[bold red]✗[/bold red]'}] Tryb bezpieczny: {'[bold green]WŁĄCZONY[/bold green]' if SAFE_MODE else '[bold red]WYŁĄCZONY'}")
        wordlist_display = f"[dim]{WORDLIST_PHASE1}[/dim]"
        if USER_CUSTOMIZED_WORDLIST_PHASE1: wordlist_display = f"[bold green]{WORDLIST_PHASE1} (Użytkownika)[/bold green]"
        elif SAFE_MODE: wordlist_display = f"[bold yellow]{SMALL_WORDLIST_PHASE1} (Safe Mode)[/bold yellow]"
        user_agent_display = f"[dim white]'{CUSTOM_HEADER}'[/dim white]"
        if USER_CUSTOMIZED_USER_AGENT and CUSTOM_HEADER: user_agent_display = f"[bold green]'{CUSTOM_HEADER}' (Użytkownika)[/bold green]"
        elif SAFE_MODE and not USER_CUSTOMIZED_USER_AGENT: user_agent_display = f"[bold yellow]Losowy + Dodatkowe (Safe Mode)[/bold yellow]"
        elif not CUSTOM_HEADER: user_agent_display = f"[dim white]Domyślny[/dim white]"
        threads_display = f"[bold yellow]{THREADS}[/bold yellow]"
        if USER_CUSTOMIZED_THREADS: threads_display = f"[bold green]{THREADS} (Użytkownika)[/bold green]"
        timeout_display = f"[bold yellow]{TOOL_TIMEOUT_SECONDS}[/bold yellow]s"
        if USER_CUSTOMIZED_TIMEOUT: timeout_display = f"[bold green]{TOOL_TIMEOUT_SECONDS}s (Użytkownika)[/bold green]"
        resolvers_display = f"[dim]{RESOLVERS_FILE}[/dim]"
        if USER_CUSTOMIZED_RESOLVERS: resolvers_display = f"[bold green]{RESOLVERS_FILE} (Użytkownika)[/bold green]"
        table.add_row("[2]", f"Lista słów (Faza 1) (aktualna: {wordlist_display})")
        table.add_row("[3]", f"User-Agent (aktualny: {user_agent_display})")
        table.add_row("[4]", f"Liczba wątków (aktualna: {threads_display})")
        table.add_row("[5]", f"Limit czasu narzędzia (aktualny: {timeout_display})")
        table.add_row("[6]", f"Plik resolverów dla Puredns (aktualny: {resolvers_display})")
        table.add_section()
        table.add_row("[\fb]", "Powrót do menu Fazy 1")
        table.add_row("[\fq]", "Wyjdź")
        console.print(Align.center(table))

        choice = get_single_char_input_with_prompt(Text.from_markup("[bold cyan]Wybierz opcję[/bold cyan]", justify="center"))
        
        if choice == '1':
            SAFE_MODE = not SAFE_MODE
            console.print(Align.center(f"[bold green]Tryb bezpieczny zmieniono na: {'WŁĄCZONY' if SAFE_MODE else 'WYŁĄCZONY'}[/bold green]"))
            if not USER_CUSTOMIZED_TIMEOUT:
                TOOL_TIMEOUT_SECONDS = 1000 if SAFE_MODE else DEFAULT_TOOL_TIMEOUT_SECONDS
                console.print(Align.center(f"[bold {'yellow' if SAFE_MODE else 'green'}]Limit czasu narzędzia {'automatycznie zwiększony do 1000s' if SAFE_MODE else 'przywrócony do domyślnego'}.[/bold {'yellow' if SAFE_MODE else 'green'}]"))
            if not USER_CUSTOMIZED_WORDLIST_PHASE1: WORDLIST_PHASE1 = SMALL_WORDLIST_PHASE1 if SAFE_MODE else DEFAULT_WORDLIST_PHASE1
            if SAFE_MODE and not USER_CUSTOMIZED_USER_AGENT and not CUSTOM_HEADER: CUSTOM_HEADER = shared_get_random_user_agent_header(user_agents_file=USER_AGENTS_FILE, console_obj=console)
            elif not SAFE_MODE and not USER_CUSTOMIZED_USER_AGENT: CUSTOM_HEADER = ""
        elif choice == '2':
            new_path = Prompt.ask("[bold cyan]Wpisz nową ścieżkę do listy słów (Faza 1)[/bold cyan] (puste=domyślna)")
            if not new_path:
                WORDLIST_PHASE1, USER_CUSTOMIZED_WORDLIST_PHASE1 = DEFAULT_WORDLIST_PHASE1, False
                console.print(Align.center(f"[bold green]Lista słów (Faza 1) zresetowana do domyślnej.[/bold green]"))
            elif os.path.isfile(new_path) and os.access(new_path, os.R_OK):
                WORDLIST_PHASE1, USER_CUSTOMIZED_WORDLIST_PHASE1 = new_path, True
                console.print(Align.center(f"[bold green]Lista słów (Faza 1) ustawiona.[/bold green]"))
            else:
                console.print(Align.center("[bold red]Ścieżka nieprawidłowa lub plik nieczytelny.[/bold red]"))
        elif choice == '3':
            new_ua = Prompt.ask("[bold cyan]Wpisz nowy User-Agent[/bold cyan] (puste=domyślny)")
            CUSTOM_HEADER, USER_CUSTOMIZED_USER_AGENT = new_ua, bool(new_ua)
            console.print(Align.center(f"[bold green]User-Agent {'ustawiony' if new_ua else 'zresetowany'}.[/bold green]"))
        elif choice == '4':
            new_threads_str = Prompt.ask("[bold cyan]Wpisz nową liczbę wątków[/bold cyan]")
            if new_threads_str.isdigit() and int(new_threads_str) > 0:
                THREADS, USER_CUSTOMIZED_THREADS = int(new_threads_str), True
                console.print(Align.center(f"[bold green]Liczba wątków ustawiona na: {THREADS}[/bold green]"))
            else:
                console.print(Align.center("[bold red]Nieprawidłowa liczba wątków.[/bold red]"))
        elif choice == '5':
            new_timeout_str = Prompt.ask("[bold cyan]Wpisz nowy limit czasu w sekundach[/bold cyan]")
            if new_timeout_str.isdigit() and int(new_timeout_str) > 0:
                TOOL_TIMEOUT_SECONDS, USER_CUSTOMIZED_TIMEOUT = int(new_timeout_str), True
                console.print(Align.center(f"[bold green]Limit czasu ustawiony na: {TOOL_TIMEOUT_SECONDS}s[/bold green]"))
            else:
                console.print(Align.center("[bold red]Nieprawidłowy limit czasu.[/bold red]"))
        elif choice == '6':
            new_path = Prompt.ask("[bold cyan]Wpisz nową ścieżkę do pliku resolverów[/bold cyan] (puste=domyślna)")
            if not new_path:
                RESOLVERS_FILE, USER_CUSTOMIZED_RESOLVERS = DEFAULT_RESOLVERS_FILE, False
                console.print(Align.center(f"[bold green]Plik resolverów zresetowany.[/bold green]"))
            elif os.path.isfile(new_path) and os.access(new_path, os.R_OK):
                RESOLVERS_FILE, USER_CUSTOMIZED_RESOLVERS = new_path, True
                console.print(Align.center(f"[bold green]Plik resolverów ustawiony.[/bold green]"))
            else:
                console.print(Align.center("[bold red]Ścieżka nieprawidłowa lub plik nieczytelny.[/bold red]"))
        elif choice.lower() == 'b': break
        elif choice.lower() == 'q': sys.exit(0)
        else: console.print(Align.center("[bold yellow]Nieprawidłowa opcja.[/bold yellow]"))
        time.sleep(0.1)

def display_phase2_tool_selection_menu():
    global selected_phase2_tools
    while True:
        console.clear()
        display_banner()
        console.print(Align.center(Panel.fit("[bold magenta]Faza 2: Wyszukiwanie Katalogów[/bold magenta]")))
        console.print(Align.center(f"Obecny cel: [bold green]{ORIGINAL_TARGET}[/bold green]"))
        console.print(Align.center(f"Tryb bezpieczny: {'[bold green]WŁĄCZONY[/bold green]' if SAFE_MODE else '[bold red]WYŁĄCZONY'}"))
        table = Table(show_header=False, show_edge=False, padding=(0, 2))
        table.add_column("Key", style="bold blue", justify="center", min_width=5)
        table.add_column("Description", style="white", justify="left")
        tool_names = ["FFuf", "Feroxbuster", "Dirsearch", "Gobuster"]
        for i, tool_name in enumerate(tool_names):
            status_char = "[bold green]✓[/bold green]" if selected_phase2_tools[i] == 1 else "[bold red]✗[/bold red]"
            table.add_row(f"[{i+1}]", f"{status_char} {tool_name}")
        table.add_section()
        table.add_row("[5]", "[bold magenta]Zmień ustawienia Fazy 2[/bold magenta]")
        table.add_row("[\fb]", "Powrót do menu głównego")
        table.add_row("[\fq]", "Wyjdź")
        console.print(Align.center(table))
        choice = get_single_char_input_with_prompt(Text.from_markup("[bold cyan]Wybierz opcję[/bold cyan]", justify="center"))
        if choice.isdigit() and 1 <= int(choice) <= 4: selected_phase2_tools[int(choice) - 1] = 1 - selected_phase2_tools[int(choice) - 1]
        elif choice == '5': display_phase2_settings_menu()
        elif choice.lower() == 'q': sys.exit(0)
        elif choice.lower() == 'b': return False
        elif choice == '\r':
            if any(selected_phase2_tools): return True
            else: console.print(Align.center("[bold yellow]Proszę wybrać co najmniej jedno narzędzie.[/bold yellow]"))
        else: console.print(Align.center("[bold yellow]Nieprawidłowa opcja.[/bold yellow]"))
        time.sleep(0.1)

def display_phase2_settings_menu():
    global WORDLIST_PHASE2, THREADS, TOOL_TIMEOUT_SECONDS, SAFE_MODE, CUSTOM_HEADER, SCAN_ONLY_CRITICAL, RECURSION_DEPTH
    global USER_CUSTOMIZED_WORDLIST_PHASE2, USER_CUSTOMIZED_USER_AGENT, USER_CUSTOMIZED_THREADS, USER_CUSTOMIZED_TIMEOUT, USER_CUSTOMIZED_SCAN_CRITICAL, USER_CUSTOMIZED_RECURSION_DEPTH
    while True:
        console.clear()
        display_banner()
        console.print(Align.center(Panel.fit("[bold cyan]Ustawienia Fazy 2[/bold cyan]")))
        table = Table(show_header=False, show_edge=False, padding=(0, 2))
        table.add_column("Key", style="bold blue", justify="center", min_width=5)
        table.add_column("Description", style="white", justify="left")
        table.add_row("[1]", f"[{'[bold green]✓[/bold green]' if SAFE_MODE else '[bold red]✗[/bold red]'}] Tryb bezpieczny")
        table.add_row("[2]", f"[{'[bold green]✓[/bold green]' if SCAN_ONLY_CRITICAL else '[bold red]✗[/bold red]'}] Skanuj tylko wyniki krytyczne")
        wordlist_display = f"[dim]{WORDLIST_PHASE2}[/dim]"
        if USER_CUSTOMIZED_WORDLIST_PHASE2: wordlist_display = f"[bold green]{WORDLIST_PHASE2} (Użytkownika)[/bold green]"
        elif SAFE_MODE: wordlist_display = f"[bold yellow]{SMALL_WORDLIST_PHASE2} (Safe Mode)[/bold yellow]"
        user_agent_display = f"[dim white]'{CUSTOM_HEADER}'[/dim white]"
        if USER_CUSTOMIZED_USER_AGENT and CUSTOM_HEADER: user_agent_display = f"[bold green]'{CUSTOM_HEADER}' (Użytkownika)[/bold green]"
        elif SAFE_MODE and not USER_CUSTOMIZED_USER_AGENT: user_agent_display = f"[bold yellow]Losowy + Dodatkowe (Safe Mode)[/bold yellow]"
        elif not CUSTOM_HEADER: user_agent_display = f"[dim white]Domyślny[/dim white]"
        threads_display = f"[bold yellow]{THREADS}[/bold yellow]"
        if USER_CUSTOMIZED_THREADS: threads_display = f"[bold green]{THREADS} (Użytkownika)[/bold green]"
        timeout_display = f"[bold yellow]{TOOL_TIMEOUT_SECONDS}[/bold yellow]s"
        if USER_CUSTOMIZED_TIMEOUT: timeout_display = f"[bold green]{TOOL_TIMEOUT_SECONDS}s (Użytkownika)[/bold green]"
        recursion_display = f"[bold yellow]{RECURSION_DEPTH}[/bold yellow]"
        if USER_CUSTOMIZED_RECURSION_DEPTH: recursion_display = f"[bold green]{RECURSION_DEPTH} (Użytkownika)[/bold green]"
        table.add_row("[3]", f"Lista słów (Faza 2): {wordlist_display}")
        table.add_row("[4]", f"User-Agent: {user_agent_display}")
        table.add_row("[5]", f"Liczba wątków: {threads_display}")
        table.add_row("[6]", f"Limit czasu narzędzia: {timeout_display}")
        table.add_row("[7]", f"Głębokość rekurencji: {recursion_display}")
        table.add_section()
        table.add_row("[\fb]", "Powrót do menu Fazy 2")
        table.add_row("[\fq]", "Wyjdź")
        console.print(Align.center(table))
        choice = get_single_char_input_with_prompt(Text.from_markup("[bold cyan]Wybierz opcję[/bold cyan]", justify="center"))
        
        if choice == '1':
            SAFE_MODE = not SAFE_MODE
            if not USER_CUSTOMIZED_TIMEOUT: TOOL_TIMEOUT_SECONDS = 1000 if SAFE_MODE else DEFAULT_TOOL_TIMEOUT_SECONDS
            if not USER_CUSTOMIZED_WORDLIST_PHASE2: WORDLIST_PHASE2 = SMALL_WORDLIST_PHASE2 if SAFE_MODE else DEFAULT_WORDLIST_PHASE2
            if SAFE_MODE and not USER_CUSTOMIZED_USER_AGENT and not CUSTOM_HEADER: CUSTOM_HEADER = shared_get_random_user_agent_header(user_agents_file=USER_AGENTS_FILE, console_obj=console)
            elif not SAFE_MODE and not USER_CUSTOMIZED_USER_AGENT: CUSTOM_HEADER = ""
        elif choice == '2': SCAN_ONLY_CRITICAL, USER_CUSTOMIZED_SCAN_CRITICAL = not SCAN_ONLY_CRITICAL, True
        elif choice == '3':
            new_path = Prompt.ask("[bold cyan]Wpisz nową ścieżkę do listy słów (Faza 2)[/bold cyan] (puste=domyślna)")
            if not new_path: WORDLIST_PHASE2, USER_CUSTOMIZED_WORDLIST_PHASE2 = DEFAULT_WORDLIST_PHASE2, False
            elif os.path.isfile(new_path) and os.access(new_path, os.R_OK): WORDLIST_PHASE2, USER_CUSTOMIZED_WORDLIST_PHASE2 = new_path, True
            else: console.print(Align.center("[bold red]Ścieżka nieprawidłowa lub plik nieczytelny.[/bold red]"))
        elif choice == '4':
            new_ua = Prompt.ask("[bold cyan]Wpisz nowy User-Agent[/bold cyan] (puste=domyślny)")
            CUSTOM_HEADER, USER_CUSTOMIZED_USER_AGENT = new_ua, bool(new_ua)
        elif choice == '5':
            new_threads_str = Prompt.ask("[bold cyan]Wpisz nową liczbę wątków[/bold cyan]")
            if new_threads_str.isdigit() and int(new_threads_str) > 0: THREADS, USER_CUSTOMIZED_THREADS = int(new_threads_str), True
            else: console.print(Align.center("[bold red]Nieprawidłowa liczba wątków.[/bold red]"))
        elif choice == '6':
            new_timeout_str = Prompt.ask("[bold cyan]Wpisz nowy limit czasu w sekundach[/bold cyan]")
            if new_timeout_str.isdigit() and int(new_timeout_str) > 0: TOOL_TIMEOUT_SECONDS, USER_CUSTOMIZED_TIMEOUT = int(new_timeout_str), True
            else: console.print(Align.center("[bold red]Nieprawidłowy limit czasu.[/bold red]"))
        elif choice == '7':
            new_depth_str = Prompt.ask("[bold cyan]Wpisz nową głębokość rekurencji (0=wyłącz)[/bold cyan]")
            if new_depth_str.isdigit() and int(new_depth_str) >= 0: RECURSION_DEPTH, USER_CUSTOMIZED_RECURSION_DEPTH = int(new_depth_str), True
            else: console.print(Align.center("[bold red]Nieprawidłowa głębokość rekurencji.[/bold red]"))
        elif choice.lower() == 'b': break
        elif choice.lower() == 'q': sys.exit(0)
        else: console.print(Align.center("[bold yellow]Nieprawidłowa opcja.[/bold yellow]"))
        time.sleep(0.1)

def display_phase3_tool_selection_menu():
    global selected_phase3_tools
    while True:
        console.clear()
        display_banner()
        console.print(Align.center(Panel.fit("[bold magenta]Faza 3: Web Crawling[/bold magenta]")))
        console.print(Align.center(f"Obecny cel: [bold green]{ORIGINAL_TARGET}[/bold green]"))
        console.print(Align.center(f"Tryb bezpieczny: {'[bold green]WŁĄCZONY[/bold green]' if SAFE_MODE else '[bold red]WYŁĄCZONY'}"))
        table = Table(show_header=False, show_edge=False, padding=(0, 2))
        table.add_column("Key", style="bold blue", justify="center", min_width=5)
        table.add_column("Description", style="white", justify="left")
        
        tool_names = ["Katana", "Hakrawler", "ParamSpider", "LinkFinder", "gauplus"]
        
        for i, tool_name in enumerate(tool_names):
            status_char = "[bold green]✓[/bold green]" if selected_phase3_tools[i] == 1 else "[bold red]✗[/bold red]"
            table.add_row(f"[{i+1}]", f"{status_char} {tool_name}")
            
        table.add_section()
        table.add_row("[\fb]", "Powrót do menu głównego")
        table.add_row("[\fq]", "Wyjdź")
        console.print(Align.center(table))
        
        choice = get_single_char_input_with_prompt(Text.from_markup("[bold cyan]Wybierz opcję[/bold cyan]", justify="center"))
        if choice.isdigit() and 1 <= int(choice) <= len(tool_names): 
            selected_phase3_tools[int(choice) - 1] = 1 - selected_phase3_tools[int(choice) - 1]
        elif choice.lower() == 'q': 
            sys.exit(0)
        elif choice.lower() == 'b': 
            return False
        elif choice == '\r':
            if any(selected_phase3_tools): 
                return True
            else: 
                console.print(Align.center("[bold yellow]Proszę wybrać co najmniej jedno narzędzie.[/bold yellow]"))
        else: 
            console.print(Align.center("[bold yellow]Nieprawidłowa opcja.[/bold yellow]"))
        
        time.sleep(0.1)

def display_main_menu():
    console.clear()
    display_banner()
    main_panel = Panel.fit("[bold cyan]ShadowMap Main Menu[/bold cyan]")
    console.print(Align.center(main_panel))
    console.print(Align.center(f"\nObecny cel: [bold green]{ORIGINAL_TARGET}[/bold green]\n"))
    table = Table(show_header=False, show_edge=False, padding=(0, 2))
    table.add_column("Key", style="bold blue", justify="center", min_width=5)
    table.add_column("Description", style="white", justify="left")
    table.add_row("[1]", "Faza 1: Odkrywanie Subdomen")
    table.add_row("[2]", "Faza 2: Wyszukiwanie Katalogów")
    table.add_row("[3]", "Faza 3: Web Crawling")
    table.add_row("[\fq]", "Wyjdź")
    console.print(Align.center(table))
    return get_single_char_input_with_prompt(Text.from_markup("\n[bold cyan]Wybierz opcję[/bold cyan]", justify="center"))

def parse_target_input(target_input: str):
    global ORIGINAL_TARGET, TARGET_IS_IP, CLEAN_DOMAIN_TARGET, HOSTNAME_TARGET
    ORIGINAL_TARGET = target_input
    clean_target = re.sub(r'^(http|https)://', '', target_input).strip('/')
    TARGET_IS_IP = bool(re.match(r"^\d{1,3}(\.\d{1,3}){3}$", clean_target))
    
    if not TARGET_IS_IP:
        hostname_match = re.search(r'([a-zA-Z0-9.-]+\.[a-zA-Z]{2,})', clean_target)
        if hostname_match:
            HOSTNAME_TARGET = hostname_match.group(1)
            parts = HOSTNAME_TARGET.split('.')
            if len(parts) > 2 and parts[-2] in ['co', 'com', 'org', 'net', 'gov', 'edu'] and len(parts) > 3:
                 CLEAN_DOMAIN_TARGET = '.'.join(parts[-3:])
            elif len(parts) > 1:
                 CLEAN_DOMAIN_TARGET = '.'.join(parts[-2:])
            else:
                 CLEAN_DOMAIN_TARGET = HOSTNAME_TARGET
        else:
            HOSTNAME_TARGET = clean_target
            CLEAN_DOMAIN_TARGET = clean_target
    else:
        HOSTNAME_TARGET = clean_target
        CLEAN_DOMAIN_TARGET = clean_target

    console.print(Align.center(f"[bold green]Hostname celu: {HOSTNAME_TARGET} | Domena główna: {CLEAN_DOMAIN_TARGET}[/bold green]"))

def check_dependencies():
    console.print(Align.center("Sprawdzanie zależności ShadowMap...", style="bold green"))
    console.print(Align.center("Wszystkie zależności wydają się być OK.", style="bold green"))

def _execute_tool_command(tool_name: str, command_parts: List[str], output_file: str, timeout: int):
    cmd_str = ' '.join(command_parts)
    console.print(f"[bold cyan]Uruchamiam {tool_name}:[/bold cyan] [dim white]{cmd_str}[/dim white]")
    try:
        process = subprocess.run(
            command_parts, 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE, 
            timeout=timeout, 
            text=True, 
            check=False, 
            encoding='utf-8', 
            errors='ignore'
        )
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(process.stdout)

        if process.stderr:
            log_and_echo(f"Komunikaty z STDERR dla '{tool_name}':\n{process.stderr.strip()}", "DEBUG")

        if process.returncode == 0:
            console.print(f"[bold green]✅ {tool_name} zakończył skanowanie.[/bold green]")
            return output_file
        else:
            log_and_echo(f"Narzędzie {tool_name} zakończyło pracę z kodem błędu ({process.returncode}), ale kontynuuję.", "WARN")
            return output_file
            
    except Exception as e:
        log_and_echo(f"BŁĄD: Ogólny błąd wykonania '{cmd_str}': {e}", "ERROR")
        console.print(Align.center(f"[bold red]❌ BŁĄD: {tool_name}: {e}[/bold red]"))
        return None

def detect_waf_and_propose_safe_mode():
    global SAFE_MODE, CUSTOM_HEADER, TOOL_TIMEOUT_SECONDS, WORDLIST_PHASE1, WORDLIST_PHASE2
    if TARGET_IS_IP: return
    
    initial_message = Text("Sprawdzam ochronę WAF...", justify="center", style="bold green")
    console.print(Align.center(Panel(initial_message, title="[cyan]Detekcja WAF[/cyan]", expand=False, border_style="cyan")))
    
    try:
        wafw00f_command = ["wafw00f", "-T", "150", ORIGINAL_TARGET]
        process = subprocess.run(wafw00f_command, capture_output=True, text=True, timeout=300, check=False, encoding='utf-8', errors='ignore')
        
        waf_name = None
        try:
            results = json.loads(process.stdout)
            if isinstance(results, list) and results:
                if results[0].get("waf_name"):
                    waf_name = results[0]["waf_name"]
        except (json.JSONDecodeError, IndexError):
            ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
            cleaned_stdout = ansi_escape.sub('', process.stdout)
            if "is behind" in cleaned_stdout or "WAF detected" in cleaned_stdout:
                 waf_name_match = re.search(r'is behind\s+([^(\n]+)', cleaned_stdout)
                 waf_name = waf_name_match.group(1).strip() if waf_name_match else "Nieznany WAF"

        if waf_name:
            waf_message = Text.from_markup(f"[bold yellow]Wykryto WAF:[/bold yellow] {waf_name}!\nZalecany tryb bezpieczny.")
            console.print(Align.center(Panel(waf_message, title="[yellow]Wynik Detekcji[/yellow]", expand=False, border_style="yellow")))
            
            if not QUIET_MODE:
                if ask_user_decision("Czy chcesz włączyć Tryb Bezpieczny?", choices=["y", "n"], default="y") == 'y':
                    SAFE_MODE = True
            else: 
                SAFE_MODE = True

            if SAFE_MODE:
                if not USER_CUSTOMIZED_TIMEOUT: TOOL_TIMEOUT_SECONDS = 1000
                if not USER_CUSTOMIZED_WORDLIST_PHASE1: WORDLIST_PHASE1 = SMALL_WORDLIST_PHASE1
                if not USER_CUSTOMIZED_WORDLIST_PHASE2: WORDLIST_PHASE2 = SMALL_WORDLIST_PHASE2
                if not USER_CUSTOMIZED_USER_AGENT and not CUSTOM_HEADER: CUSTOM_HEADER = shared_get_random_user_agent_header(USER_AGENTS_FILE, console)
                console.print(Align.center(Panel(Text("Tryb Bezpieczny WŁĄCZONY.", justify="center"), style="bold green", expand=False)))
        else:
            no_waf_message = Text("Nie wykryto WAF lub sprawdzanie było niejednoznaczne.", justify="center", style="bold green")
            console.print(Align.center(Panel(no_waf_message, title="[green]Wynik Detekcji[/green]", expand=False, border_style="green")))
    except Exception as e:
        log_and_echo(f"Błąd podczas uruchamiania wafw00f: {e}", "ERROR")
        error_message = Text(f"Błąd podczas detekcji WAF: {e}", justify="center", style="bold red")
        error_panel = Panel(error_message, title="[red]Błąd Krytyczny[/red]", expand=False, border_style="red")
        console.print(error_panel)

def start_phase1_scan():
    global REPORT_DIR, selected_phase1_tools, ORIGINAL_TARGET, THREADS, TOOL_TIMEOUT_SECONDS, WORDLIST_PHASE1, SAFE_MODE, CUSTOM_HEADER, RESOLVERS_FILE, CLEAN_DOMAIN_TARGET
    
    console.print(Align.center(f"[bold green]Rozpoczynam Fazę 1 - Odkrywanie Subdomen dla {ORIGINAL_TARGET}...[/bold green]"))
    
    with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"), BarColumn(), MofNCompleteColumn(), "•", TimeElapsedColumn(), console=console, transient=True) as progress:
        task1_total = sum(1 for i, enabled in enumerate(selected_phase1_tools) if enabled and not (TARGET_IS_IP and i < 3))
        task1 = progress.add_task("[green]Faza 1 (Subdomeny)[/green]", total=task1_total)

        current_wordlist_p1 = WORDLIST_PHASE1
        if SAFE_MODE:
            if not USER_CUSTOMIZED_WORDLIST_PHASE1: current_wordlist_p1 = SMALL_WORDLIST_PHASE1
            if not USER_CUSTOMIZED_USER_AGENT and not CUSTOM_HEADER: CUSTOM_HEADER = shared_get_random_user_agent_header(USER_AGENTS_FILE, console)
            shuffled_wordlist_p1_path = shared_shuffle_wordlist(current_wordlist_p1, REPORT_DIR)
            if shuffled_wordlist_p1_path:
                current_wordlist_p1 = shuffled_wordlist_p1_path
                TEMP_FILES_TO_CLEAN.append(shuffled_wordlist_p1_path)
        
        puredns_base_cmd = ["puredns", "bruteforce", current_wordlist_p1, CLEAN_DOMAIN_TARGET, "--resolvers", RESOLVERS_FILE]
        tool_configurations = [
            {"name": "Subfinder", "cmd_template": ["subfinder", "-d", CLEAN_DOMAIN_TARGET, "-silent"]},
            {"name": "Assetfinder", "cmd_template": ["assetfinder", "--subs-only", CLEAN_DOMAIN_TARGET]},
            {"name": "Findomain", "cmd_template": ["findomain", "--target", CLEAN_DOMAIN_TARGET, "-q"]},
            {"name": "Puredns", "cmd_template": puredns_base_cmd + ["--rate-limit", "1000", "-q"]}
        ]

        if SAFE_MODE:
            tool_configurations[3]["cmd_template"] = puredns_base_cmd + ["--rate-limit", "50", "-q"]
        tasks_to_run = []
        for i, config in enumerate(tool_configurations):
            if selected_phase1_tools[i] == 1:
                if TARGET_IS_IP and config["name"] in ["Subfinder", "Assetfinder", "Findomain"]: continue
                output_path = os.path.join(REPORT_DIR, f"{config['name'].lower()}_results.txt")
                tasks_to_run.append((config["name"], config["cmd_template"], output_path))
                TEMP_FILES_TO_CLEAN.append(output_path)
        if not tasks_to_run:
            console.print(Align.center("Nie wybrano narzędzi do odkrywania subdomen. Pomijam.", style="bold yellow"))
            return {}, []
        output_files_collected = {}
        with ThreadPoolExecutor(max_workers=THREADS) as executor:
            futures = {executor.submit(_execute_tool_command, name, cmd, out, TOOL_TIMEOUT_SECONDS): name for name, cmd, out in tasks_to_run}
            for future in as_completed(futures):
                tool_name = futures[future]
                result_file = future.result()
                if result_file:
                    output_files_collected[tool_name] = result_file
                progress.update(task1, advance=1)

    console.print(Align.center("Integracja wyników...", style="bold green"))
    unique_subdomains_file = os.path.join(REPORT_DIR, "all_subdomains_unique.txt")
    TEMP_FILES_TO_CLEAN.append(unique_subdomains_file)
    all_lines = []
    for f_path in output_files_collected.values():
        if os.path.exists(f_path):
            with open(f_path, 'r', encoding='utf-8') as f:
                all_lines.extend(f.readlines())
    
    unique_lines = sorted(list(set(line.strip().lower() for line in all_lines if line.strip() and (f".{CLEAN_DOMAIN_TARGET}" in line.lower() or line.strip().lower() == CLEAN_DOMAIN_TARGET))))
    
    with open(unique_subdomains_file, 'w', encoding='utf-8') as f:
        f.write('\n'.join(unique_lines))
    
    active_urls = []
    with console.status("[bold green]Weryfikuję subdomeny za pomocą HTTPX...[/bold green]"):
        httpx_output_file = os.path.join(REPORT_DIR, "httpx_results_phase1.txt")
        httpx_command = ["httpx", "-l", unique_subdomains_file, "-silent", "-fc", "404", "-json"]
        if SAFE_MODE:
            httpx_command.extend(["-p", "80,443,8000,8080,8443", "-rate-limit", "10"])
            extra_headers = shared_get_random_browser_headers()
            for header in extra_headers: httpx_command.extend(["-H", header])
            if CUSTOM_HEADER: httpx_command.extend(["-H", f"User-Agent: {CUSTOM_HEADER}"])
            else: httpx_command.extend(["-H", f"User-Agent: {shared_get_random_user_agent_header(USER_AGENTS_FILE)}"])
        elif CUSTOM_HEADER: httpx_command.extend(["-H", f"User-Agent: {CUSTOM_HEADER}"])
        
        if os.path.exists(unique_subdomains_file) and os.path.getsize(unique_subdomains_file) > 0:
            httpx_result_file = _execute_tool_command("Httpx (Faza 1)", httpx_command, httpx_output_file, TOOL_TIMEOUT_SECONDS)
            if httpx_result_file:
                output_files_collected["Httpx"] = httpx_result_file
                with open(httpx_result_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        try:
                            url = json.loads(line).get("url")
                            if url: active_urls.append(url)
                        except (json.JSONDecodeError, TypeError): continue
    
    return output_files_collected, sorted(list(set(active_urls)))

def start_phase2_scan(httpx_results_urls: List[str]):
    if not httpx_results_urls:
        console.print(Align.center("[bold yellow]Brak URL-i do skanowania w Fazie 2.[/bold yellow]"))
        return {}, ""
    
    console.print(Align.center(f"\n[bold green]Rozpoczynam Fazę 2 - Wyszukiwanie Katalogów dla {len(httpx_results_urls)} aktywnych URL-i...[/bold green]"))
    
    task2_total = len(httpx_results_urls) * sum(selected_phase2_tools)
    
    with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"), BarColumn(), MofNCompleteColumn(), "•", TimeElapsedColumn(), console=console, transient=True) as progress:
        task2 = progress.add_task("[green]Faza 2 (Katalogi)[/green]", total=task2_total if task2_total > 0 else 1)
        phase2_all_results, phase2_verified_results_httpx = phase2_start_dir_search(
            urls=httpx_results_urls, 
            report_dir=REPORT_DIR, 
            safe_mode=SAFE_MODE, 
            custom_header=CUSTOM_HEADER, 
            wordlist_path=WORDLIST_PHASE2, 
            small_wordlist_path=SMALL_WORDLIST_PHASE2, 
            threads=THREADS, 
            tool_timeout=TOOL_TIMEOUT_SECONDS, 
            log_file=LOG_FILE, 
            user_agents_file=USER_AGENTS_FILE, 
            selected_tools_config=selected_phase2_tools, 
            recursion_depth=RECURSION_DEPTH, 
            console_obj=console, 
            progress_obj=progress, 
            main_task_id=task2
        )
    
    return phase2_all_results, phase2_verified_results_httpx

def start_phase3_scan(urls_to_scan: List[str], global_progress: Progress, global_task: TaskID):
    if not urls_to_scan:
        console.print(Align.center("[bold yellow]Brak URL-i do skanowania w Fazie 3.[/bold yellow]"))
        return {}
    console.print(Align.center(f"\n[bold green]Rozpoczynam Fazę 3 - Web Crawling dla {len(urls_to_scan)} URL-i...[/bold green]"))
    return phase3_start_web_crawl(urls=urls_to_scan, report_dir=REPORT_DIR, safe_mode=SAFE_MODE, custom_header=CUSTOM_HEADER, threads=THREADS, tool_timeout=TOOL_TIMEOUT_SECONDS, log_file=LOG_FILE, user_agents_file=USER_AGENTS_FILE, selected_tools_config=selected_phase3_tools, console_obj=console, progress_obj=global_progress, main_task_id=global_task)

def run_httpx_on_phase3_results(p3_raw_results: Dict[str, List[str]], progress: Progress, task: TaskID) -> Tuple[str, int]:
    console.print(Align.center("[bold green]Faza 3: Weryfikacja znalezionych adresów URL za pomocą HTTPX...[/bold green]"))
    
    all_urls_p3 = set()
    for url_list in p3_raw_results.values():
        all_urls_p3.update(url_list)
    
    if not all_urls_p3:
        console.print(Align.center("[bold yellow]Faza 3: Nie znaleziono żadnych URLi do weryfikacji.[/bold yellow]"))
        return "", 0

    urls_to_scan_file = os.path.join(REPORT_DIR, "phase3_all_urls_for_httpx.txt")
    TEMP_FILES_TO_CLEAN.append(urls_to_scan_file)
    with open(urls_to_scan_file, 'w', encoding='utf-8') as f:
        for url in sorted(list(all_urls_p3)):
            f.write(f"{url}\n")
            
    httpx_output_file = os.path.join(REPORT_DIR, "httpx_results_phase3.txt")

    httpx_command = ["httpx", "-l", urls_to_scan_file, "-silent", "-json"]
    if SAFE_MODE:
        httpx_command.extend(["-rate-limit", "10"])
        if CUSTOM_HEADER: httpx_command.extend(["-H", f"User-Agent: {CUSTOM_HEADER}"])
        else: httpx_command.extend(["-H", f"User-Agent: {shared_get_random_user_agent_header(USER_AGENTS_FILE)}"])
    elif CUSTOM_HEADER: httpx_command.extend(["-H", f"User-Agent: {CUSTOM_HEADER}"])
        
    result_file = _execute_tool_command("Httpx (Faza 3)", httpx_command, httpx_output_file, TOOL_TIMEOUT_SECONDS * 2)
    
    active_count = 0
    if result_file and os.path.exists(result_file):
        with open(result_file, 'r', encoding='utf-8') as f:
            for line in f:
                if line.strip():
                    active_count += 1
    
    progress.update(task, completed=progress.tasks[task].total)
    console.print(Align.center(f"[bold green]Faza 3: HTTPX zakończył, znaleziono {active_count} aktywnych endpointów.[/bold green]"))
    return httpx_output_file, active_count


def open_html_report(report_path: str):
    if sys.platform == "win32": os.startfile(report_path)
    elif sys.platform == "darwin": subprocess.run(["open", report_path])
    else:
        try: subprocess.run(["xdg-open", report_path])
        except FileNotFoundError: console.print(Align.center("[bold yellow]xdg-open nie znaleziono. Otwórz raport ręcznie.[/bold yellow]"))

def generate_html_report(
    p1_files: Dict, 
    p2_results: Dict, 
    p2_verified_httpx: str,
    p3_raw_results: Dict,
    p3_httpx_file_path: str
):
    console.print(Align.center("[bold blue]Generowanie raportu HTML...[/bold blue]"))

    try:
        with open(HTML_TEMPLATE_PATH, 'r', encoding='utf-8') as f:
            template = f.read()
    except FileNotFoundError:
        log_and_echo(f"Krytyczny błąd: Nie znaleziono szablonu raportu w {HTML_TEMPLATE_PATH}", "ERROR")
        return

    replacements = {}
    
    def get_content_and_count(source, is_file=True) -> Tuple[str, int]:
        if is_file:
            if not source or not os.path.exists(source):
                return "Brak danych", 0
            with open(source, 'r', encoding='utf-8') as f:
                lines = [line.strip() for line in f if line.strip()]
        else:
            lines = source if source else []
        
        return "<br>".join(lines), len(lines)

    def escape_for_js(data_string: str) -> str:
        """Safely escapes a string for embedding in JavaScript within quotes."""
        if not data_string:
            return ""
        return json.dumps(data_string)[1:-1]

    replacements['{{DOMAIN}}'] = CLEAN_DOMAIN_TARGET

    p1_sub_files = {k: v for k, v in p1_files.items() if k != 'Httpx'}
    all_subdomains_list = []
    for file_path in p1_sub_files.values():
        if file_path and os.path.exists(file_path):
            with open(file_path, 'r', encoding='utf-8') as f:
                all_subdomains_list.extend(line.strip() for line in f if line.strip())
    
    all_subdomains_unique = sorted(list(set(all_subdomains_list)))
    
    replacements['{{SUBFINDER_OUTPUT}}'], replacements['{{COUNT_SUBFINDER}}'] = get_content_and_count(p1_files.get('Subfinder'))
    replacements['{{ASSETFINDER_OUTPUT}}'], replacements['{{COUNT_ASSETFINDER}}'] = get_content_and_count(p1_files.get('Assetfinder'))
    replacements['{{FINDOMAIN_OUTPUT}}'], replacements['{{COUNT_FINDOMAIN}}'] = get_content_and_count(p1_files.get('Findomain'))
    replacements['{{PUREDNS_OUTPUT}}'], replacements['{{COUNT_PUREDNS}}'] = get_content_and_count(p1_files.get('Puredns'))
    replacements['{{ALL_SUBDOMAINS_OUTPUT}}'] = "<br>".join(all_subdomains_unique)
    replacements['{{COUNT_ALL_SUBDOMAINS}}'] = str(len(all_subdomains_unique))

    httpx_p1_content_raw = ""
    httpx_p1_count = 0
    if p1_files.get('Httpx') and os.path.exists(p1_files.get('Httpx')):
        with open(p1_files.get('Httpx'), 'r', encoding='utf-8') as f:
            lines = f.readlines()
            httpx_p1_count = len(lines)
            httpx_p1_content_raw = "".join(lines)
    replacements['{{HTTPX_OUTPUT_RAW_FOR_JS}}'] = escape_for_js(httpx_p1_content_raw)
    replacements['{{COUNT_HTTPX}}'] = str(httpx_p1_count)

    # Faza 2
    p2_all_results_list = p2_results.get('all_dirsearch_results', [])
    dirsearch_all_for_js = "\n".join(p2_all_results_list)
    replacements['{{DIR_SEARCH_ALL_OUTPUT}}'] = escape_for_js(dirsearch_all_for_js)
    replacements['{{COUNT_DIR_SEARCH}}'] = str(len(p2_all_results_list))
    
    replacements['{{DIRSEARCH_SPECIFIC_OUTPUT}}'], _ = get_content_and_count(p2_results.get('dirsearch'), is_file=False)
    replacements['{{FFUF_SPECIFIC_OUTPUT}}'], _ = get_content_and_count(p2_results.get('ffuf'), is_file=False)
    replacements['{{FEROXBUSTER_SPECIFIC_OUTPUT}}'], _ = get_content_and_count(p2_results.get('feroxbuster'), is_file=False)
    replacements['{{GOBUSTER_SPECIFIC_OUTPUT}}'], _ = get_content_and_count(p2_results.get('gobuster'), is_file=False)
    replacements['{{HTTPX_PHASE2_VERIFIED_OUTPUT}}'] = escape_for_js(p2_verified_httpx)

    # Faza 3
    replacements['{{PHASE3_ALL_URLS_OUTPUT}}'], replacements['{{COUNT_ALL_URLS}}'] = get_content_and_count(p3_raw_results.get('all_urls'), is_file=False)
    replacements['{{PARAMETERS_OUTPUT}}'], replacements['{{COUNT_PARAMETERS}}'] = get_content_and_count(p3_raw_results.get('parameters'), is_file=False)
    replacements['{{JS_FILES_OUTPUT}}'], replacements['{{COUNT_JS_FILES}}'] = get_content_and_count(p3_raw_results.get('js_files'), is_file=False)
    replacements['{{API_ENDPOINTS_OUTPUT}}'], replacements['{{COUNT_API_ENDPOINTS}}'] = get_content_and_count(p3_raw_results.get('api_endpoints'), is_file=False)
    replacements['{{INTERESTING_PATHS_OUTPUT}}'], replacements['{{COUNT_INTERESTING_PATHS}}'] = get_content_and_count(p3_raw_results.get('interesting_paths'), is_file=False)

    all_urls_combined = sorted(list(set(p2_results.get('all_dirsearch_results', []) + p3_raw_results.get('all_urls', []))))
    all_urls_combined_content, all_urls_combined_count = get_content_and_count(all_urls_combined, is_file=False)
    replacements['{{ALL_URLS_COMBINED_OUTPUT}}'] = all_urls_combined_content
    replacements['{{COUNT_ALL_URLS_COMBINED}}'] = str(all_urls_combined_count)

    for placeholder, value in replacements.items():
        template = template.replace(str(placeholder), str(value))
        
    remaining_placeholders = re.findall(r'\{\{.*?\}\}', template)
    for placeholder in remaining_placeholders:
        if "COUNT" in placeholder:
            template = template.replace(placeholder, "0")
        else:
            template = template.replace(placeholder, "Brak danych")

    report_path = os.path.join(REPORT_DIR, "report.html")
    try:
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(template)
        console.print(Align.center(f"[bold green]Raport HTML został pomyślnie wygenerowany: {report_path}[/bold green]"))
    except Exception as e:
        log_and_echo(f"Nie udało się zapisać raportu HTML: {e}", "ERROR")

def cleanup_temp_files():
    console.print(Align.center("Czyszczę pliki tymczasowe...", style="bold green"))
    for f_path in TEMP_FILES_TO_CLEAN:
        try:
            if os.path.exists(f_path): os.remove(f_path)
        except Exception as e:
            log_and_echo(f"Nie można usunąć pliku '{f_path}': {e}", "WARN")

def main(
    target: str = typer.Argument(..., help="Domain or IP address to scan."),
    quiet: bool = typer.Option(False, "--quiet", "-q", help="Runs the scan in quiet mode (non-interactive)"),
    output_dir: Optional[Path] = typer.Option(None, "--output-dir", "-o", help="Output directory for the report"),
    assume_yes: bool = typer.Option(False, "--yes", "-y", help="Automatically accept all interactive prompts."),
    no_report: bool = typer.Option(False, "--no-report", help="Skips HTML report generation."),
    log_file: Optional[Path] = typer.Option(None, "--log-file", "-l", help="Saves logs to a file."),
    phase2_only: bool = typer.Option(False, "--phase2-only", help="Run only Phase 2 (Dir searching)."),
    phase3_only: bool = typer.Option(False, "--phase3-only", help="Run only Phase 3 (Web Crawling)."),
):
    global QUIET_MODE, LOG_FILE, OUTPUT_BASE_DIR, REPORT_DIR, selected_phase1_tools, selected_phase2_tools, selected_phase3_tools, \
           WORDLIST_PHASE1, WORDLIST_PHASE2, SAFE_MODE, CUSTOM_HEADER, SCAN_ONLY_CRITICAL, \
           USER_CUSTOMIZED_WORDLIST_PHASE1, USER_CUSTOMIZED_WORDLIST_PHASE2, USER_CUSTOMIZED_USER_AGENT, \
           DEFAULT_WORDLIST_PHASE1, DEFAULT_WORDLIST_PHASE2, DEFAULT_THREADS, DEFAULT_TOOL_TIMEOUT_SECONDS

    scan_initiated = False

    try:
        QUIET_MODE = quiet
        if log_file:
            LOG_FILE = str(log_file)
            logging.basicConfig(filename=LOG_FILE, level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

        if output_dir: OUTPUT_BASE_DIR = str(output_dir)
        parse_target_input(target)
        check_dependencies()
        
        phase1_output_files, httpx_active_urls, phase2_all_results, phase3_raw_results, phase3_httpx_file = {}, [], {}, {}, ""
        phase2_verified_results_httpx = ""
        urls_for_phase2 = []
        selected_paths_from_p2 = []

        phase1_run, phase2_run, phase3_run = False, False, False

        if QUIET_MODE:
            phase1_run = not (phase2_only or phase3_only)
            phase2_run = True
            phase3_run = True
            selected_phase1_tools = [1,1,1,1] if not TARGET_IS_IP else [0,0,0,1]
            selected_phase2_tools = [1,1,1,1]
            selected_phase3_tools = [1,1,1,1,1]
        else:
            choice = ""
            while choice.lower() != 'q' and not (phase1_run or phase2_run or phase3_run or phase2_only or phase3_only):
                choice = display_main_menu()
                if choice == '1': phase1_run = display_phase1_tool_selection_menu()
                elif choice == '2': phase2_run = display_phase2_tool_selection_menu()
                elif choice == '3': phase3_run = display_phase3_tool_selection_menu()

        if phase1_run or phase2_run or phase3_run or phase2_only or phase3_only:
            scan_initiated = True
            REPORT_DIR = os.path.join(OUTPUT_BASE_DIR, f"report_{HOSTNAME_TARGET}_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}")
            os.makedirs(REPORT_DIR, exist_ok=True)
            console.print(f"[bold green]Katalog raportu: {REPORT_DIR}[/bold green]")
            
            if not QUIET_MODE:
                detect_waf_and_propose_safe_mode()

            if phase1_run:
                phase1_output_files, httpx_active_urls = start_phase1_scan()
            
            if phase1_run and not phase2_run and not QUIET_MODE and not phase2_only:
                if httpx_active_urls:
                    if ask_user_decision("Czy chcesz kontynuować do Fazy 2 (Wyszukiwanie katalogów)?", ["y", "n"], "y") == 'y':
                        critical_urls = filter_critical_urls(httpx_active_urls)
                        if critical_urls:
                            summary_q = (f"Faza 1 znalazła [bold green]{len(httpx_active_urls)}[/bold green] aktywnych hostów, w tym [bold yellow]{len(critical_urls)}[/bold yellow] krytycznych.\n"
                                       "Skanować wszystkie [bold](a)[/bold] czy tylko krytyczne [bold](c)[/bold]?")
                            scan_choice = ask_user_decision(summary_q, choices=["a", "c"], default="a")
                            if scan_choice == 'c':
                                urls_for_phase2 = critical_urls
                                console.print(Align.center(Panel(Text.from_markup("OK, Faza 2 przeskanuje tylko [underline]krytyczne[/underline] hosty.", justify="center"), title="[yellow]Informacja[/yellow]", border_style="yellow", expand=False)))
                            else:
                                urls_for_phase2 = httpx_active_urls
                                console.print(Align.center(Panel(Text.from_markup("OK, Faza 2 przeskanuje [underline]wszystkie[/underline] znalezione hosty.", justify="center"), title="[green]Informacja[/green]", border_style="green", expand=False)))
                        else:
                            info_text = f"Faza 1 znalazła [bold green]{len(httpx_active_urls)}[/bold green] aktywnych hostów (brak krytycznych). Skanuję wszystkie."
                            console.print(Align.center(Panel(Text.from_markup(info_text, justify="center"), title="[green]Informacja[/green]", border_style="green", expand=False)))
                            urls_for_phase2 = httpx_active_urls
                        
                        phase2_run = display_phase2_tool_selection_menu()

            if not urls_for_phase2 and (phase2_run or phase2_only):
                urls_for_phase2 = [ORIGINAL_TARGET] if not httpx_active_urls else httpx_active_urls
            
            if (phase2_run or phase2_only) and urls_for_phase2:
                phase2_all_results, phase2_verified_results_httpx = start_phase2_scan(urls_for_phase2)

            if (phase2_run or phase2_only) and not phase3_run and not QUIET_MODE and not phase3_only:
                phase2_found_paths = phase2_all_results.get("all_dirsearch_results", [])
                if phase2_found_paths:
                    if ask_user_decision("Czy chcesz kontynuować do Fazy 3 (Web Crawling)?", ["y", "n"], "y") == 'y':
                        critical_paths = filter_critical_urls(phase2_found_paths)
                        if critical_paths:
                            summary_q = (f"Faza 2 znalazła [bold green]{len(phase2_found_paths)}[/bold green] ścieżek, w tym [bold yellow]{len(critical_paths)}[/bold yellow] krytycznych.\n"
                                       "Skanować wszystkie [bold](a)[/bold] czy tylko krytyczne [bold](c)[/bold]?")
                            scan_choice = ask_user_decision(summary_q, choices=["a", "c"], default="a")
                            if scan_choice == 'c':
                                selected_paths_from_p2 = critical_paths
                                console.print(Align.center(Panel(Text.from_markup("OK, Faza 3 przeskanuje tylko [underline]krytyczne[/underline] ścieżki.", justify="center"), title="[yellow]Informacja[/yellow]", border_style="yellow", expand=False)))
                            else:
                                selected_paths_from_p2 = phase2_found_paths
                                console.print(Align.center(Panel(Text.from_markup("OK, Faza 3 przeskanuje [underline]wszystkie[/underline] znalezione ścieżki.", justify="center"), title="[green]Informacja[/green]", border_style="green", expand=False)))
                        else:
                            info_text_p2 = f"Faza 2 znalazła [bold green]{len(phase2_found_paths)}[/bold green] ścieżek (brak krytycznych). Skanuję wszystkie."
                            console.print(Align.center(Panel(Text.from_markup(info_text_p2, justify="center"), title="[green]Informacja[/green]", border_style="green", expand=False)))
                            selected_paths_from_p2 = phase2_found_paths
                        
                        phase3_run = display_phase3_tool_selection_menu()

            urls_for_phase3 = sorted(list(set(httpx_active_urls + selected_paths_from_p2)))
            if not urls_for_phase3 and (phase3_run or phase3_only):
                urls_for_phase3 = [ORIGINAL_TARGET]

            if phase3_run or phase3_only:
                with Progress(SpinnerColumn(), TextColumn("[progress.description]{task.description}"), BarColumn(), MofNCompleteColumn(), "•", TimeElapsedColumn(), console=console, transient=True) as progress:
                    tool_names = ["Katana", "Hakrawler", "ParamSpider", "LinkFinder", "gauplus"]
                    task3_total = (len(urls_for_phase3) * sum(1 for t_name in ["Katana", "Hakrawler", "ParamSpider", "gauplus"] if selected_phase3_tools[tool_names.index(t_name)]))
                    if selected_phase3_tools[tool_names.index("LinkFinder")]:
                        task3_total += 1

                    task3 = progress.add_task("[green]Faza 3 (Crawling)[/green]", total=task3_total if task3_total > 0 else 1)
                    phase3_raw_results = start_phase3_scan(urls_for_phase3, progress, task3)
                    
                    if phase3_raw_results.get("all_urls"):
                        task4 = progress.add_task("[magenta]Faza 3 (HTTPX Verify)[/magenta]", total=1)
                        phase3_httpx_file, _ = run_httpx_on_phase3_results(phase3_raw_results, progress, task4)
            
            console.print(Align.center(f"\n[bold green]Skanowanie zakończono dla: {ORIGINAL_TARGET}[/bold green]"))
            if not no_report:
                generate_html_report(phase1_output_files, phase2_all_results, phase2_verified_results_httpx, phase3_raw_results, phase3_httpx_file)
                report_path = os.path.join(REPORT_DIR, "report.html")
                if os.path.exists(report_path):
                    if not QUIET_MODE:
                        open_html_report(report_path)

    except KeyboardInterrupt:
        console.print("\n\n[bold yellow]Przerwano przez użytkownika. Zamykanie...[/bold yellow]")
    
    finally:
        if scan_initiated:
            cleanup_temp_files()

if __name__ == "__main__":
    typer.run(main)

